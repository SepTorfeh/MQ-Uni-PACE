import {createAsyncThunk, createSlice, PayloadAction} from "@reduxjs/toolkit";
import {fetchSurveySubmit} from "./survey-api";

export interface SurveyState {
    loading: boolean;
    error: string | boolean;
    persona: string | undefined;
}


const userInfoFromStorage = localStorage.getItem("userInfo")
    ? JSON.parse(localStorage.getItem("userInfo") || '{}')
    : null;

const initialState: SurveyState = {
    loading: false,
    error: false,
    persona: userInfoFromStorage ? userInfoFromStorage.persona : "",
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// return an action creator to generate promise lifecircle actions: pending, fullfilled and rejected
export const fetchSurveySubmitAsync = createAsyncThunk(
    //1. action lifecircle prefix
    "survey/fetchSurveySubmit",
    //2. payload creator
    async (surveyPayload: {persona: string;}) => {
        const response = await fetchSurveySubmit(
            surveyPayload.persona,
        );
        // The value we return becomes the action payload
        return response;
    },
    // 3. options [optional] e.g. request cancelling or retry and etc
);

export const surveySlice = createSlice({
    name: "survey",
    initialState,
    reducers: {
        updatePersona: (state, action: PayloadAction<string>) => {
            state.persona = action.payload;
        },

    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: builder => {
        // Add reducers for additional action types here, and handle loading state as needed
        builder
            .addCase(fetchSurveySubmitAsync.pending, state => {
                // will dispatch action: login/fetchUserLogin/pending
                state.loading = true;
                state.error = false;
                state.persona = "";
            })
            .addCase(fetchSurveySubmitAsync.fulfilled, (state, action) => {
                // will dispatch action: login/fetchUserLogin/fulfilled
                state.loading = false;
                state.persona = action.payload;
                state.error = false;
            })
            .addCase(fetchSurveySubmitAsync.rejected, (state, action) => {
                // will dispatch action: login/fetchUserLogin/rejected
                state.loading = false;
                state.error = action.error.message as string | boolean;
                state.persona = "";
            });
    },
});

export const {updatePersona} = surveySlice.actions;

export default surveySlice.reducer;

